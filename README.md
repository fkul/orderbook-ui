# My Trading Interface

The objective was to implement a real time orderbook with the assumption that this codebase will be built on in the future. Patterns and implementation details used scale to an application of much larger size - a trading interface.

_This repository uses [yarn workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) to handle multiple packages. Packages-specific documentation can be found within the particular folders of the packages._

## Feature set

- A functional, real time orderbook including totals and spread
- Depth graph is correctly displayed with optimizations for performance
- A "Toggle Feed" button that allows to switch contracts
- Design is responsive with orientation changing on mobile devices
- The WebSocket feed is being disconnected once the app looses focus
- Rerender requests are throttled

## Getting started

```sh
# First, install all dependencies:
yarn install

# Then build the required packages:
yarn build:packages

# Finally run the development server:
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Structure

- `my-trading-interface` - main code of the trading interface
- `packages` - packages used by the trading interface

## Choices

### CSS

My first choice for handling CSS is normally `styled-components`, but since performance was key for this project I've decided to go for a build-time CSS in JS solution (recommended article: [Real-world CSS vs. CSS-in-JS performance comparison](https://pustelto.com/blog/css-vs-css-in-js-perf/)). I've tested two most popular libraries out there: [linaria](https://github.com/callstack/linaria) and [compiled](https://github.com/atlassian-labs/compiled) by Atlassian Labs and even though the latter felt more production-ready, it's still relatively young and has some [major features missing](https://compiledcssinjs.com/docs/limitations#missing-behavior). This is why I stuck to linaria.

### Detecting page visibility and media queries

I've decided to move the logic for throttling, detecting the page visibility and screen width into a higher-order component. This is because I can easily imagine other elements of the trading interface (`widgets`) making use of those features as well.

I'm using mature libraries: [react-page-visibility](https://github.com/pgilad/react-page-visibility) for page visibility detection and [react-responsive](https://github.com/contra/react-responsive) for media queries. Having information about the screen width in JS instead of only in CSS allows to additionally trim the Orderbook entries for better performance.

### Moving logic into packages

Moving parts of the code into packages (`@fkul/avg` and `@fkul/react-cf-ws-api`) helps to better separate presentation from logic. It also allows to reuse the packages in other projects.

### WebSocket connection

The package `@fkul/react-cf-ws-api` is using the [react-use-websocket](https://github.com/robtaussig/react-use-websocket) library to establish a WebSocket connection. I've used it successfully in other projects, so the choice with obvious. One great feature I'm making use of in this case as well is the ability to share the WebSocket connection. Multiple components can use a single WebSocket, which is closed and cleaned up when all subscribed components have unsubscribed/unmounted. This allows to initiate the `useCfWs()` hook within the `widget` and not worry that it will end up creating several connections with multiple `widgets` using it.

### Throttling

I'm using [lodash/throttle](https://lodash.com/docs/4.17.15#throttle) to perform the throttling itself, but the logic to calculate the wait time is based on the average time that the `widget's` content is generated by the browser.

## Caveats

- Linaria is not able to use variables in globals, making theming harder
- RWD breakpoints are hardcoded, which is also result of linaria's limitations

## Testing

The command below will run tests in every workspace of the repository:

```sh
yarn test
```
